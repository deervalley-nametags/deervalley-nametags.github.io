{"version":3,"sources":["js/dbUtility.js"],"names":["namesRef","promiseReturn","loginAs","user","pass","Promise","resolve","reject","firebase","auth","setPersistence","Auth","Persistence","NONE","then","signInWithEmailAndPassword","catch","error","errorCode","code","errorMessage","message","msg","checkAuth","onAuthStateChanged","console","log","email","dbUtility","utilityObj","apps","initializeApp","apiKey","authDomain","projectId","db","firestore","collection","sqrtNonPattern","Math","sqrt","mode","authUser","authPass","returned","where","get","querySnapshot","forEach","doc","findIndex","obj","id","push","data","searchForString","writeData","arrayItem","index","tagName","name","tagRequestor","requestor","prependNameArray","toLowerCase","prependRequestorArray","nameArray","split","requestorArray","unshift","currentTimestamp","Date","getTime","color","add","namearray","attachment","signcolor","signColor","signquantity","signQuantity","height","width","thickness","requestorarray","comments","daterequest","datefinished","titlecity","secondLine","thirdline","thirdLine","quantity","type","date","docIdArray","item","update"],"mappings":"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","file":"static/js/1.25edd3df.chunk.js","sourcesContent":["import firebase from 'firebase/app';\r\nimport 'firebase/auth';\r\nimport 'firebase/firestore';\r\n\r\n// highest order variables\r\nlet namesRef; // db reference\r\nlet promiseReturn;\r\n\r\nfunction loginAs(user, pass){\r\n    return new Promise((resolve, reject) => {\r\n        \r\n        firebase.auth().setPersistence(firebase.auth.Auth.Persistence.NONE)\r\n        .then(function() {\r\n            // persistence types:\r\n            // .NONE = reload will not keep session\r\n            // .SESSION = reload will keep session, but closing and reopening will not\r\n            \r\n            return firebase.auth().signInWithEmailAndPassword(user, pass);\r\n        })\r\n        .then(function(){\r\n            resolve(true);\r\n        })\r\n        .catch(function(error) {\r\n            //  Handle Errors here.\r\n            let errorCode = error.code;\r\n            let errorMessage = error.message;\r\n            // console.log(errorCode + \" -1- \" + errorMessage);\r\n\r\n            reject({\r\n                code: errorCode,\r\n                msg: errorMessage\r\n            });\r\n        });\r\n    });\r\n};\r\n\r\nfunction checkAuth(){\r\n    // check auth\r\n    return new Promise((resolve, reject) => {\r\n        firebase.auth().onAuthStateChanged(function(user) {\r\n            if(user){\r\n                //  User is signed in.\r\n                console.log(\"checkAuth() passed with user: \" + user.email);\r\n        \r\n                resolve(user.email);\r\n            }else{\r\n                //  No user is signed in.\r\n                console.log(\"checkAuth() failed: no credentials.\");\r\n            };\r\n        });\r\n\r\n    });\r\n};\r\n\r\nexport function dbUtility(utilityObj){\r\n    /*\r\n    this is a master use-all use-anywhere connect to db PROMISE\r\n    so if you are switching from firebase to something else, you know\r\n    exactly what needs to be replaced\r\n    -\r\n    its a promise because it relies on waiting on the authentication mainly\r\n    so can use it like dbUtility({mode:\"\"}).then(() => { // do stuff here });\r\n    -\r\n    utilityObj has the following data structure for its different modes:\r\n    {\r\n        mode: \"auth\",\r\n        authUser: \"\",\r\n        authPass: \"\"\r\n    }\r\n    {\r\n        mode: \"new_entry\",\r\n        writeData: [{name:,requestor:,etc},{},// etc]\r\n    }\r\n    {\r\n        mode: \"search_for\", // returns array full of found tags\r\n        searchForString: \"string to search\"\r\n    }\r\n    {\r\n        mode: \"read_all\" // returns array full of objects full of tags\r\n    }\r\n    {\r\n        mode: \"update_entry\",\r\n        type: \"done\" or \"notdone\"\r\n        docIdArray: [\"id\",\"id\",\"id\",// etc]\r\n    }\r\n    */\r\n   \r\n\r\n    // if not yet initialized, initialize\r\n    // debug: typeof firebase.apps[0] comes undefined if not previously init, or object if init\r\n    // console.dir(typeof firebase.apps[0]);\r\n    if(typeof firebase.apps[0] == \"undefined\"){\r\n       // not init yet\r\n       \r\n       // firebase init using firestore\r\n       firebase.initializeApp({\r\n           apiKey: 'AIzaSyA1uPdDnmLSWqkuEkFlGH5YF7UvxvszceU',\r\n           authDomain: 'nametags-4019a.firebaseapp.com',\r\n           projectId: 'nametags-4019a'\r\n        });\r\n        \r\n        // creation of db\r\n        const db = firebase.firestore();\r\n        namesRef = db.collection(\"names\");\r\n        \r\n        // db authenticate as anon\r\n        // bad obfuscation time\r\n        let sqrtNonPattern = Math.sqrt(4356);\r\n        sqrtNonPattern = \"iamanonymous\" + sqrtNonPattern;\r\n        sqrtNonPattern = sqrtNonPattern + \"6\";\r\n        loginAs(\"anonymous@deervalley.com\",sqrtNonPattern);\r\n        \r\n    }\r\n    \r\n\r\n    // authenticate\r\n    if(utilityObj.mode === \"auth\"){\r\n        return new Promise((resolve, reject) => {\r\n            // first login, must wait so it is a promise\r\n            loginAs(utilityObj.authUser, utilityObj.authPass).then( () => {\r\n                // now we need to use check auth in order to grab the user\r\n                checkAuth().then( returned => {\r\n                    // only if user is admin, resolve\r\n                    // console.log(\"pio \" + returned);\r\n                    resolve(returned);\r\n                }).catch( error => {\r\n                    \r\n                });\r\n            }).catch( error => {\r\n                reject(error);\r\n            });\r\n        });\r\n    };\r\n    \r\n\r\n    // mode check\r\n    if(utilityObj.mode === \"read_all\"){\r\n        /*\r\n        read all mode, but because of read limits on google firebase free version, only\r\n        grab the unfinished tags\r\n        -\r\n        set return type to array before pushing\r\n        */\r\n        promiseReturn = [];\r\n        \r\n        // return promise\r\n        return new Promise((resolve, reject) => {\r\n\r\n            // check auth before getting doc data\r\n            checkAuth().then(function(){\r\n                namesRef.where(\"datefinished\", \"==\", 0).get().then(function(querySnapshot){\r\n                    querySnapshot.forEach(function(doc){\r\n                        // for each document found as unfinished, array push the following\r\n\r\n                        // search for any matching id's in promiseReturn\r\n                        // this section is because for some reason it was duplicating, so now it only does one once\r\n                        let priorExistingId = promiseReturn.findIndex(obj => obj.id === doc.id);\r\n                        if(priorExistingId === -1){\r\n                            // -1 means it did not find a prior id, so go ahead\r\n                            // array push the following\r\n                            promiseReturn.push({\r\n                                id: doc.id,\r\n                                data: doc.data()\r\n                            });\r\n                        }else{\r\n                            // anything else means if found something prior, so do nothing\r\n                        }\r\n                    });\r\n                    resolve(promiseReturn);\r\n                });\r\n            });\r\n\r\n        });\r\n\r\n\r\n    }else if(utilityObj.mode === \"search_for\"){\r\n        // search mode\r\n        let promiseReturn = [];\r\n\r\n        // return promise\r\n        return new Promise((resolve, reject) => {\r\n            // check auth before getting doc data\r\n            checkAuth().then(function(){\r\n                // grab results where name is being searched for\r\n                namesRef.where(\"namearray\", \"array-contains-any\", [utilityObj.searchForString]).get().then(function(querySnapshot){\r\n                    querySnapshot.forEach(function(doc){\r\n                        // for each document found, array push the following\r\n                        promiseReturn.push({\r\n                            id: doc.id,\r\n                            data: doc.data()\r\n                        });\r\n                    });\r\n                }).then(function(){\r\n                    // now grab all results where requestor could be searched for, this allows duplicate results\r\n                    namesRef.where(\"requestorarray\", \"array-contains-any\", [utilityObj.searchForString]).get().then(function(querySnapshot){\r\n                        querySnapshot.forEach(function(doc){\r\n                            // for each document found\r\n                            \r\n                            // search for any matching id's in promiseReturn\r\n                            let priorExistingId = promiseReturn.findIndex(obj => obj.id === doc.id);\r\n                            if(priorExistingId === -1){\r\n                                // -1 means it did not find a prior id, so go ahead\r\n                                // array push the following\r\n                                promiseReturn.push({\r\n                                    id: doc.id,\r\n                                    data: doc.data()\r\n                                });\r\n                            }else{\r\n                                // anything else means if found something prior, so do nothing\r\n                            }\r\n                        });\r\n                        resolve(promiseReturn);\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }else if(utilityObj.mode === \"new_entry\"){\r\n        /*\r\n        used for new entries\r\n        data in:\r\n        array[{name:\"\",requestor:\"\",secondLine:\"\",thirdLine:\"\",requestor:\"\",comments:\"\"},{},{},etc]\r\n        -\r\n        set return type to array before pushing\r\n        */\r\n        promiseReturn = [];\r\n\r\n        // debug: what does writeData come in as\r\n        // console.log(utilityObj.writeData);\r\n\r\n        // return promise\r\n        return new Promise((resolve, reject) => {\r\n            // check auth before submitting\r\n            checkAuth().then(function(){\r\n                utilityObj.writeData.forEach(function(arrayItem, index){\r\n                    // console.log(arrayItem);\r\n\r\n                    // lower casify and split name to an array, searching can be done easilyer\r\n                    let tagName = arrayItem.name;\r\n                    let tagRequestor = arrayItem.requestor;\r\n                    let prependNameArray = tagName.toLowerCase();\r\n                    let prependRequestorArray = tagRequestor.toLowerCase();\r\n            \r\n                    // before split, add temp var and prepend name to array, so \"Jake Smith\"\r\n                    // looks like [\"jake smith\",\"jake\",\"smith\"]\r\n                    let nameArray = prependNameArray.split(\" \");\r\n                    let requestorArray = prependRequestorArray.split(\" \");\r\n                    nameArray.unshift(prependNameArray);\r\n                    requestorArray.unshift(prependRequestorArray);\r\n                    \r\n                    // grab current timestamp\r\n                    let date = new Date();\r\n                    let currentTimestamp = date.getTime();\r\n            \r\n                    // if sign, add only sign stuff\r\n                    if(arrayItem.color === 5){\r\n                        // sign\r\n                        // make a new document in db, auto gen id\r\n                        namesRef.add({\r\n                            name: tagName,\r\n                            namearray: nameArray,\r\n                            color: 5,\r\n                            attachment: arrayItem.attachment,\r\n                            signcolor: arrayItem.signColor,\r\n                            signquantity: arrayItem.signQuantity,\r\n                            height: arrayItem.height,\r\n                            width: arrayItem.width,\r\n                            thickness: arrayItem.thickness,\r\n                            requestor: tagRequestor,\r\n                            requestorarray: requestorArray,\r\n                            comments: arrayItem.comments,\r\n                            daterequest: currentTimestamp,\r\n                            datefinished: 0\r\n                        }).then(function(){\r\n                            // debug when writing is successful\r\n                            // console.log(\"writing good\");\r\n                            resolve(true);\r\n                        });\r\n                    }else{\r\n                        // anything other than sign\r\n                        // make a new document in db, auto gen id\r\n                        namesRef.add({\r\n                            name: tagName,\r\n                            namearray: nameArray,\r\n                            color: arrayItem.color,\r\n                            titlecity: arrayItem.secondLine,\r\n                            thirdline: arrayItem.thirdLine,\r\n                            requestor: tagRequestor,\r\n                            requestorarray: requestorArray,\r\n                            comments: arrayItem.comments,\r\n                            daterequest: currentTimestamp,\r\n                            datefinished: 0,\r\n                            quantity: arrayItem.quantity\r\n                        }).then(function(){\r\n                            // debug when writing is successful\r\n                            // console.log(\"writing good\");\r\n                            resolve(true);\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        });\r\n\r\n    }else if(utilityObj.mode === \"auth\"){\r\n        // if auth is called here, just do nothing, as there is a section above that handles it,\r\n        // but if this was empty it would throw some form of error\r\n    }else if(utilityObj.mode === \"update_entry\"){\r\n        // return promise\r\n        return new Promise((resolve, reject) => {\r\n\r\n            // update entry, mainly used to update if admin finished or unfinished a tag\r\n            let currentTimestamp;\r\n\r\n            // handle types\r\n            if(utilityObj.type === \"done\"){\r\n                // update to done\r\n                // grab current timestamp\r\n                let date = new Date();\r\n                currentTimestamp = date.getTime();\r\n\r\n            }else if(utilityObj.type === \"notdone\"){\r\n                // update to not done, aka undo\r\n                currentTimestamp = 0;\r\n            }else{\r\n                // mode not supported\r\n            }\r\n\r\n            // now update db for each\r\n            utilityObj.docIdArray.forEach((item, index) => {\r\n                // debug: does item come out as the doc Id?\r\n                // console.log(item);\r\n                \r\n                namesRef.doc(item).update({\r\n                    datefinished: currentTimestamp\r\n                })\r\n                .then(function() {\r\n                    console.log(\"Document successfully written on update_entry()!\");\r\n                    resolve(true);\r\n                })\r\n                .catch(function(error) {\r\n                    console.error(\"Error writing document on update_entry(): \", error);\r\n                });\r\n\r\n            });\r\n        });\r\n    }else{\r\n        // something else encountered\r\n        console.log(\"dbUtility() was called using a non supported utilityObj mode.\");\r\n        console.log(\"supported modes are 'read_all', 'search_for', 'new_entry', 'update_entry', or 'auth'.\");\r\n        console.log(utilityObj.mode);\r\n    };\r\n\r\n};\r\n"],"sourceRoot":""}